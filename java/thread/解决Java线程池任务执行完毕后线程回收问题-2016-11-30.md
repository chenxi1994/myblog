#线程学习笔记
1.java怎么为创建的线程分配内存空间？<br/>
&emsp;&emsp;事实上我以前也是对java创建新的线程分配内存空间一直有个误解，按照我以前的想法，一个java的应用程序就相当于一个进程，而一个进程中有很多线程，每个
进程间是相互独立的。java程序在启动的时候会向操作系统申请jvm内存空间，具体申请多大的内存空间是根据当前应用的配置来的，比如：-Xms4096m，-Xmx4096m
表示申请了堆内存为4096M，对于其它的jvm内存空间大小，如果自己不设置配置参数，jdk会默认一个比例，具体是什么比例，这里就不需要详细说明了，不过配置jvm
的内存参数合理会大大的增加程序的性能，这里就涉及到了jvm性能调优的一些知识了。所以我就想jvm已经申请了内存空间，而线程又是在jvm中运行的，认为每创建一
个线程就在jvm申请内存资源。但最近才发现这是错误的，java创建线程和运行线程其实是调度操作系统的线程，每创建一个线程会向操作系统申请一个本地线程，直接
向操作系统申请资源，所以不会受java自身的控制。但是每个线程所申请的资源大小是有java决定的，因为java需要估算一个多大的内存资源用来存储线程本身的模型，
在jdk5.0以后默认是1M。这个大小也可以通过配置实现。

        System.out.println("当前线程数" + Thread.getAllStackTraces().size() + ",当前空闲内存" + Runtime.getRuntime().freeMemory());
                for (int i = 0; i < 150; i++) {
                    new Thread(new Runnable() {
                        @Override
                        public void run() {
                            try {
                                Thread.sleep(2000); //睡眠2秒，便于有时间观察
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                        }
                    }).start();
                }
                try {
                    Thread.sleep(1000); //睡眠1秒，确保所有线程正在执行
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
        System.out.println("当前线程数" + Thread.getAllStackTraces().size() + ",当前空闲内存" + Runtime.getRuntime().freeMemory());
运行结果如下：

        当前线程数6,当前空闲内存121341480
        当前线程数156,当前空闲内存121341480
&emsp;&emsp;由上面的代码示例可以看出，最开始只有5个线程，当我创建150个线程后，前后的空闲内存并没有改变，但是我打开window的资源管理器可以明确的看到线程增加了100
左右，内存使用也上升了几十M，这里我也不明白为什么不是100M左右。我用的是jdk1.7。
2. 线程池的由来
