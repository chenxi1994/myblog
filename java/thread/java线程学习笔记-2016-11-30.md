#线程学习笔记
1. java怎么为创建的线程分配内存空间？<br/>
&emsp;&emsp;事实上我以前也是对java创建新的线程分配内存空间一直有个误解，按照我以前的想法，一个java的应用程序就相当于一个进程，而一个进程中有很多线程，每个
进程间是相互独立的。java程序在启动的时候会向操作系统申请jvm内存空间，具体申请多大的内存空间是根据当前应用的配置来的，比如：-Xms4096m，-Xmx4096m
表示申请了堆内存为4096M，对于其它的jvm内存空间大小，如果自己不设置配置参数，jdk会默认一个比例，具体是什么比例，这里就不需要详细说明了，不过配置jvm
的内存参数合理会大大的增加程序的性能，这里就涉及到了jvm性能调优的一些知识了。所以我就想jvm已经申请了内存空间，而线程又是在jvm中运行的，认为每创建一
个线程就在jvm申请内存资源。但最近才发现这是错误的，java创建线程和运行线程其实是调度操作系统的线程，每创建一个线程会向操作系统申请一个本地线程，直接
向操作系统申请资源，所以不会受java自身的控制。但是每个线程所申请的资源大小是有java决定的，因为java需要估算一个多大的内存资源用来存储线程本身的模型，
在jdk5.0以后默认是1M。这个大小也可以通过配置实现。

        System.out.println("当前线程数" + Thread.getAllStackTraces().size() + ",当前空闲内存" + Runtime.getRuntime().freeMemory());
                for (int i = 0; i < 150; i++) {
                    new Thread(new Runnable() {
                        @Override
                        public void run() {
                            try {
                                Thread.sleep(2000); //睡眠2秒，便于有时间观察
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                        }
                    }).start();
                }
                try {
                    Thread.sleep(1000); //睡眠1秒，确保所有线程正在执行
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
        System.out.println("当前线程数" + Thread.getAllStackTraces().size() + ",当前空闲内存" + Runtime.getRuntime().freeMemory());
运行结果如下：

        当前线程数6,当前空闲内存121341480
        当前线程数156,当前空闲内存121341480
&emsp;&emsp;由上面的代码示例可以看出，最开始只有5个线程，当我创建150个线程后，前后的空闲内存并没有改变，但是我打开window的资源管理器可以明确的看到线
程增加了100左右，内存使用也上升了几十M，这里我也不明白为什么不是100M左右。我用的是jdk1.7。<br/>

2. java线程的5种基本状态<br/>
新建状态(new)：创建一个新的线程，java中通过new Thread()实现。
就绪状态(runnable)：当调用了线程对象的start()方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。处
于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行在线程运行之后，从等待或者睡眠中回来之
后，也会处于就绪状态。 
运行状态(running)：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就绪状态是进入到运行状态的唯一入口，也就是说，
线程要想进入运行状态执行，首先必须处于就绪状态中； 
阻塞状态(blocked)：线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致
线程阻塞。
(1). 等待阻塞 -- 运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；JVM会把该线程放入等待池中。
(2). 同步阻塞 -- 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；JVM会把该线程放入锁池中。
(3). 其他阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。
死亡状态(dead)：如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪。 
3. java线程就绪、运行和死亡状态之间的相互转换。<br/>
就绪状态转换为运行状态：当此线程得到处理器资源；
运行状态转换为就绪状态：当此线程主动调用yield()方法或在运行过程中失去处理器资源。
运行状态转换为死亡状态：当此线程线程执行体执行完毕或发生了异常。
此处需要特别注意的是：当调用线程的yield()方法时，线程从运行状态转换为就绪状态，但接下来CPU调度就绪状态中的哪个线程具有一定的随机性，因此，可能会出现A线程调用了yield()方法后，接下来CPU仍然调度了A线程的情况。
